package com.mineclawd.kubejs;

import com.mineclawd.MineClawd;
import net.minecraft.server.MinecraftServer;
import net.fabricmc.loader.api.FabricLoader;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;

public final class KubeJsScriptManager {
    private static final String SCRIPT_FILE_NAME = "mineclawd-internal-api.js";
    private static final String SCRIPT_CONTENT = String.join("\n",
            "// Generated by MineClawd. Do not edit.",
            "let TextClass = null;",
            "try { TextClass = Java.loadClass('net.minecraft.network.chat.Component'); } catch (e) {}",
            "if (TextClass == null) {",
            "  try { TextClass = Java.loadClass('net.minecraft.text.Text'); } catch (e) {}",
            "}",
            "",
            "const StringArgumentType = Java.loadClass('com.mojang.brigadier.arguments.StringArgumentType');",
            "const Base64Class = Java.loadClass('java.util.Base64');",
            "const JavaString = Java.loadClass('java.lang.String');",
            "",
            "function toText(message) {",
            "  if (TextClass == null) return String(message);",
            "  return TextClass.literal(String(message));",
            "}",
            "",
            "function sendOk(source, message) {",
            "  const text = toText(message);",
            "  if (source.sendFeedback) { source.sendFeedback(() => text, false); return; }",
            "  if (source.sendSuccess) { source.sendSuccess(text, false); return; }",
            "  if (source.sendMessage) { source.sendMessage(text); return; }",
            "}",
            "",
            "function sendErr(source, message) {",
            "  const text = toText(message);",
            "  if (source.sendError) { source.sendError(text); return; }",
            "  if (source.sendFailure) { source.sendFailure(text); return; }",
            "  if (source.sendMessage) { source.sendMessage(text); return; }",
            "}",
            "",
            "ServerEvents.commandRegistry(event => {",
            "  const Commands = event.commands;",
            "  const Arguments = event.arguments;",
            "",
            "  event.register(",
            "    Commands.literal('_exec_kubejs_internal')",
            "      .requires(source => source.hasPermission(2))",
            "      .then(Commands.argument('code', Arguments.GREEDY_STRING.create(event))",
            "        .executes(ctx => {",
            "          try {",
            "            let encoded = '';",
            "            try {",
            "              encoded = StringArgumentType.getString(ctx, 'code');",
            "            } catch (argErr) {",
            "              try {",
            "                encoded = ctx.getArgument('code', JavaString);",
            "              } catch (argErr2) {",
            "                sendErr(ctx.source, argErr2);",
            "                return 0;",
            "              }",
            "            }",
            "            if (encoded == null) encoded = '';",
            "            let code = '';",
            "            try {",
            "              let bytes = Base64Class.getUrlDecoder().decode(String(encoded));",
            "              code = String(new JavaString(bytes, 'UTF-8'));",
            "            } catch (decodeErr) {",
            "              sendErr(ctx.source, 'Failed to decode tool payload: ' + String(decodeErr));",
            "              return 0;",
            "            }",
            "            code = String(code).replace(/\\\\n/g, '\\n');",
            "            let source = ctx.source;",
            "            let server = null;",
            "            try {",
            "              if (typeof Utils !== 'undefined' && Utils.getServer) server = Utils.getServer();",
            "            } catch (e) {}",
            "            if (server == null) {",
            "              try {",
            "                if (source.getServer) server = source.getServer();",
            "                else if (source.server) server = source.server;",
            "              } catch (e) {}",
            "            }",
            "            let level = null;",
            "            try {",
            "              if (source.getLevel) level = source.getLevel();",
            "              else if (source.level) level = source.level;",
            "            } catch (e) {}",
            "            let player = null;",
            "            try {",
            "              if (source.player) player = source.player;",
            "              else if (source.getPlayer) player = source.getPlayer();",
            "              else if (source.getPlayerOrException) player = source.getPlayerOrException();",
            "            } catch (e) {}",
            "            let result = eval(code);",
            "            if (result === undefined) result = 'undefined';",
            "            sendOk(ctx.source, result);",
            "            return 1;",
            "          } catch (err) {",
            "            let details = '';",
            "            try { details = String(err); } catch (ignored) { details = 'Unknown JS error'; }",
            "            try { if (err != null && err.stack) details += '\\n' + String(err.stack); } catch (ignored) {}",
            "            try { if (err != null && err.javaException) details += '\\n' + String(err.javaException); } catch (ignored) {}",
            "            console.error('[MineClawd] _exec_kubejs_internal error:', err);",
            "            sendErr(ctx.source, details);",
            "            return 0;",
            "          }",
            "        })",
            "      )",
            "  );",
            "});"
    );

    private KubeJsScriptManager() {
    }

    public static Path getScriptPath(Path runDir) {
        return runDir.resolve("kubejs").resolve("server_scripts").resolve(SCRIPT_FILE_NAME);
    }

    public static Path getScriptPath(MinecraftServer server) {
        Path runDir = server.getRunDirectory().toPath();
        return getScriptPath(runDir);
    }

    public static boolean ensureScriptInGameDir() {
        Path gameDir = FabricLoader.getInstance().getGameDir();
        return ensureScript(gameDir);
    }

    public static boolean ensureScript(MinecraftServer server) {
        if (server == null) {
            return false;
        }
        return ensureScript(server.getRunDirectory().toPath());
    }

    public static boolean ensureScript(Path runDir) {
        if (runDir == null) {
            return false;
        }
        Path scriptPath = getScriptPath(runDir);
        try {
            Files.createDirectories(scriptPath.getParent());
            if (Files.exists(scriptPath)) {
                String existing = Files.readString(scriptPath);
                if (SCRIPT_CONTENT.equals(existing)) {
                    return false;
                }
            }
            Files.writeString(scriptPath, SCRIPT_CONTENT, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
            return true;
        } catch (IOException e) {
            MineClawd.LOGGER.error("Failed to create KubeJS internal script at {}", scriptPath, e);
            return false;
        }
    }
}
