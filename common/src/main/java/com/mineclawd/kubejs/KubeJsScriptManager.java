package com.mineclawd.kubejs;

import com.mineclawd.MineClawd;
import dev.architectury.platform.Platform;
import net.minecraft.server.MinecraftServer;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;

public final class KubeJsScriptManager {
    private static final String SCRIPT_FILE_NAME = "mineclawd-internal-api.js";
    private static final String SCRIPT_CONTENT = String.join("\n",
            "// Generated by MineClawd. Do not edit.",
            "let TextClass = null;",
            "try { TextClass = Java.loadClass('net.minecraft.network.chat.Component'); } catch (e) {}",
            "if (TextClass == null) {",
            "  try { TextClass = Java.loadClass('net.minecraft.text.Text'); } catch (e) {}",
            "}",
            "",
            "const StringArgumentType = Java.loadClass('com.mojang.brigadier.arguments.StringArgumentType');",
            "const Base64Class = Java.loadClass('java.util.Base64');",
            "const JavaString = Java.loadClass('java.lang.String');",
            "let MineClawdBridge = null;",
            "try { MineClawdBridge = Java.loadClass('com.mineclawd.kubejs.KubeJsAgentBridge'); } catch (e) {",
            "  console.error('[MineClawd] Failed to load KubeJS agent bridge: ' + String(e));",
            "}",
            "",
            "function toText(message) {",
            "  if (TextClass == null) return String(message);",
            "  return TextClass.literal(String(message));",
            "}",
            "",
            "function sendOk(source, message) {",
            "  const text = toText(message);",
            "  if (source.sendFeedback) { source.sendFeedback(() => text, false); return; }",
            "  if (source.sendSuccess) { source.sendSuccess(text, false); return; }",
            "  if (source.sendMessage) { source.sendMessage(text); return; }",
            "}",
            "",
            "function sendErr(source, message) {",
            "  const text = toText(message);",
            "  if (source.sendError) { source.sendError(text); return; }",
            "  if (source.sendFailure) { source.sendFailure(text); return; }",
            "  if (source.sendMessage) { source.sendMessage(text); return; }",
            "}",
            "",
            "function resolveServerFromContext(context) {",
            "  if (context == null) {",
            "    try { if (typeof Utils !== 'undefined' && Utils.getServer) return Utils.getServer(); } catch (e) {}",
            "    return null;",
            "  }",
            "  try { if (context.getServer) return context.getServer(); } catch (e) {}",
            "  try { if (context.server) return context.server; } catch (e) {}",
            "  try { if (context.player && context.player.getServer) return context.player.getServer(); } catch (e) {}",
            "  try { if (context.source && context.source.getServer) return context.source.getServer(); } catch (e) {}",
            "  return null;",
            "}",
            "",
            "function resolveSourceFromContext(context, server) {",
            "  if (context != null) {",
            "    try { if (context.getSource) return context.getSource(); } catch (e) {}",
            "    try { if (context.source) return context.source; } catch (e) {}",
            "    try { if (context.player && context.player.getCommandSource) return context.player.getCommandSource().withMaxLevel(4); } catch (e) {}",
            "  }",
            "  try { if (server != null && server.getCommandSource) return server.getCommandSource().withMaxLevel(4); } catch (e) {}",
            "  return null;",
            "}",
            "",
            "const mineclawdApi = {};",
            "mineclawdApi.requestWithSession = function(player, sessionRef, request) {",
            "  if (MineClawdBridge == null) return 'ERROR: MineClawd bridge is unavailable.';",
            "  return MineClawdBridge.requestWithSession(",
            "    player,",
            "    String(sessionRef == null ? '' : sessionRef),",
            "    String(request == null ? '' : request)",
            "  );",
            "};",
            "mineclawdApi.requestOneShot = function(request, context) {",
            "  if (MineClawdBridge == null) return 'ERROR: MineClawd bridge is unavailable.';",
            "  let server = resolveServerFromContext(context);",
            "  if (server == null) {",
            "    try { if (typeof Utils !== 'undefined' && Utils.getServer) server = Utils.getServer(); } catch (e) {}",
            "  }",
            "  let source = resolveSourceFromContext(context, server);",
            "  return MineClawdBridge.requestOneShot(",
            "    source,",
            "    server,",
            "    String(request == null ? '' : request)",
            "  );",
            "};",
            "mineclawdApi.callWithSession = mineclawdApi.requestWithSession;",
            "mineclawdApi.callOneShot = mineclawdApi.requestOneShot;",
            "const mineclawd = mineclawdApi;",
            "",
            "console.info('[MineClawd] KubeJS bridge ready: use `mineclawd.*` in this script context.');",
            "",
            "ServerEvents.commandRegistry(event => {",
            "  const Commands = event.commands;",
            "  const Arguments = event.arguments;",
            "",
            "  event.register(",
            "    Commands.literal('_exec_kubejs_internal')",
            "      .requires(source => source.hasPermission(2))",
            "      .then(Commands.argument('code', Arguments.GREEDY_STRING.create(event))",
            "        .executes(ctx => {",
            "          try {",
            "            let encoded = '';",
            "            try {",
            "              encoded = StringArgumentType.getString(ctx, 'code');",
            "            } catch (argErr) {",
            "              try {",
            "                encoded = ctx.getArgument('code', JavaString);",
            "              } catch (argErr2) {",
            "                sendErr(ctx.source, argErr2);",
            "                return 0;",
            "              }",
            "            }",
            "            if (encoded == null) encoded = '';",
            "            let code = '';",
            "            try {",
            "              let bytes = Base64Class.getUrlDecoder().decode(String(encoded));",
            "              code = String(new JavaString(bytes, 'UTF-8'));",
            "            } catch (decodeErr) {",
            "              sendErr(ctx.source, 'Failed to decode tool payload: ' + String(decodeErr));",
            "              return 0;",
            "            }",
            "            code = String(code).replace(/\\\\n/g, '\\n');",
            "            let source = ctx.source;",
            "            let server = null;",
            "            try {",
            "              if (typeof Utils !== 'undefined' && Utils.getServer) server = Utils.getServer();",
            "            } catch (e) {}",
            "            if (server == null) {",
            "              try {",
            "                if (source.getServer) server = source.getServer();",
            "                else if (source.server) server = source.server;",
            "              } catch (e) {}",
            "            }",
            "            let level = null;",
            "            try {",
            "              if (source.getLevel) level = source.getLevel();",
            "              else if (source.level) level = source.level;",
            "            } catch (e) {}",
            "            let player = null;",
            "            try {",
            "              if (source.player) player = source.player;",
            "              else if (source.getPlayer) player = source.getPlayer();",
            "              else if (source.getPlayerOrException) player = source.getPlayerOrException();",
            "            } catch (e) {}",
            "            let result = eval(code);",
            "            if (result === undefined) result = 'undefined';",
            "            sendOk(ctx.source, result);",
            "            return 1;",
            "          } catch (err) {",
            "            let details = '';",
            "            try { details = String(err); } catch (ignored) { details = 'Unknown JS error'; }",
            "            try { if (err != null && err.stack) details += '\\n' + String(err.stack); } catch (ignored) {}",
            "            try { if (err != null && err.javaException) details += '\\n' + String(err.javaException); } catch (ignored) {}",
            "            console.error('[MineClawd] _exec_kubejs_internal error: ' + details);",
            "            sendErr(ctx.source, details);",
            "            return 0;",
            "          }",
            "        })",
            "      )",
            "  );",
            "});"
    );

    private KubeJsScriptManager() {
    }

    public static Path getScriptPath(Path runDir) {
        return runDir.resolve("kubejs").resolve("server_scripts").resolve(SCRIPT_FILE_NAME);
    }

    public static Path getScriptPath(MinecraftServer server) {
        Path runDir = server.getRunDirectory().toPath();
        return getScriptPath(runDir);
    }

    public static boolean ensureScriptInGameDir() {
        Path gameDir = Platform.getGameFolder();
        return ensureScript(gameDir);
    }

    public static boolean ensureScript(MinecraftServer server) {
        if (server == null) {
            return false;
        }
        return ensureScript(server.getRunDirectory().toPath());
    }

    public static boolean ensureScript(Path runDir) {
        if (runDir == null) {
            return false;
        }
        Path scriptPath = getScriptPath(runDir);
        try {
            Files.createDirectories(scriptPath.getParent());
            if (Files.exists(scriptPath)) {
                String existing = Files.readString(scriptPath);
                if (SCRIPT_CONTENT.equals(existing)) {
                    return false;
                }
            }
            Files.writeString(scriptPath, SCRIPT_CONTENT, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
            return true;
        } catch (IOException e) {
            MineClawd.LOGGER.error("Failed to create KubeJS internal script at {}", scriptPath, e);
            return false;
        }
    }
}
